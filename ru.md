## 1. Использовать HTTP-методы по назначению

- **GET** — для получения ресурсов (идемпотентный)
- **POST** — для создания нового ресурса
- **PUT** — для обновления ресурса (идемпотентный)
- **DELETE** — для удаления ресурса (идемпотентный)
- **PATCH** — для частичного изменения ресурса

## 2. Применять HTTP-глаголы корректно

- **Неправильно:**

  ```http
  GET /products/123/delete
  ```

- **Правильно:**

  ```http
  DELETE /products/123
  ```

## 3. Возвращать соответствующие HTTP-статусы

- **Неправильно:**

  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json

  {
    "error": "Product not found",
    "status_code": 404
  }
  ```

- **Правильно:**

  ```http
  HTTP/1.1 404 Not Found
  Content-Type: application/json

  {
    "error": "Product not found"
  }
  ```

## 4. Именовать конечные точки во множественном числе

```http
https://example.com/v1/users
https://example.com/v2/products
```

## 5. Избегать глаголов в именах ресурсов

- **Неправильно:**

  ```http
  GET /getProducts
  ```

- **Правильно:**

  ```http
  GET /products
  ```

## 6. Структурировать иерархию эндпоинтов логично и лаконично

- **Неправильно:**

  ```http
  /reviews/123?productId=213
  /users/2/products/4452/.../..
  ```

- **Правильно:**

  ```http
  /products/42/reviews/123
  /users/7
  ```

## 7. Версионировать API с помощью номера версии в URL

```http
GET /v1/users
GET /v2/users
```

## 8. Использовать параметры запроса для фильтрации, сортировки и пагинации

- **Неправильно:**

  ```http
  GET /products/expensive/sortedByPrice
  ```

- **Правильно:**

  ```http
  GET /products?price=high&sort=price
  GET /products?category=new&sort=name&limit=10&offset=20
  ```

## 9. Указывать единицы измерения и формат даты при работе с параметрами

- **Неправильно:**

  ```http
  GET /products?shippedOn=20230315
  GET /products?weight=5
  ```

- **Правильно:**

  ```http
  GET /products?shippedOn=2023-03-15        # ISO 8601
  GET /products?weight=5&weightUnit=kg
  ```

## 10. Не передавать конфиденциальные данные в URL; использовать тело запроса

- **Неправильно:**

  ```http
  https://example.com/login?password=myPassword
  https://example.com/register?email=unsafeMail
  ```

- **Правильно:**
  Передавать «чувствительные» данные (пароли, токены, персональную информацию) в теле POST- или PUT-запроса, а не в query-параметрах или заголовках.

## 11. Всегда оборачивать ответ в объект на верхнем уровне

- **Неправильно:**

  ```json
  [0, 1, 2, 3]
  ```

- **Правильно:**

  ```json
  {
  	"data": [0, 1, 2, 3]
  }
  ```

## 12. Работать с датами в формате ISO 8601

```text
2025-06-05T14:30:00Z
```

## 13. Ориентироваться на потребности клиента и избегать внутренних терминов

- **Неправильно:**

  ```http
  GET /cdc    # change-data-capture
  ```

- **Правильно:**

  ```http
  GET /changes
  ```

## 14. Реализовать фильтрацию, сортировку и пагинацию

- **Неправильно:**

  ```http
  GET /products    # возвращаем весь набор данных без ограничений
  ```

- **Правильно:**

  ```http
  GET /products?category=new&sort=name&limit=10&offset=20
  ```

## 15. Предоставлять понятные и информативные сообщения об ошибках

- **Неправильно:**

  ```json
  {
  	"error": "Что-то пошло не так"
  }
  ```

- **Правильно:**

  ```json
  {
  	"error": "Продукт не найден",
  	"status_code": 404
  }
  ```

## 16. Кэшировать часто запрашиваемые или статичные данные

- **Неправильно:**
  Вычитывать данные из первоисточника при каждом запросе.
- **Правильно:**
  Использовать кэширование (Redis, in-memory и т. д.) для часто запрашиваемых или редко меняющихся данных.

## 17. Реализовать «health check» для проверки статуса API

```http
GET /health    # возвращает текущий статус API
```

## 18. Использовать ограничение частоты запросов (rate limiter) и троттлинг

- **Неправильно:**
  Нет ограничений на количество запросов.
- **Правильно:**
  Ограничивать количество запросов в единицу времени (например, 100 запросов в минуту) для предотвращения DDoS-атак и злоупотреблений.

## 19. Применять балансировщик нагрузки (load balancer)

- **Неправильно:**
  Запрос API идёт напрямую на единственный сервер.
- **Правильно:**
  Запрос сначала проходит через балансировщик нагрузки, который распределяет трафик между несколькими экземплярами сервиса.

## 20. Писать качественные тесты для API

- **Неправильно:**
  Нет автоматических тестов.
- **Правильно:**
  Реализовать:
  - Unit-тесты
  - Интеграционные тесты
  - End-to-end тесты
  - Performance-тесты

## 21. Внедрять мониторинг и оповещения

- **Неправильно:**
  Отсутствует система мониторинга.
- **Правильно:**

  - Подключены инструменты мониторинга (Prometheus, Zabbix и т. д.).
  - Настроены оповещения (Slack, PagerDuty и т. д.) при критических событиях (падение сервиса, высокий CPU/RAM и т. д.).

## 22. Использовать HTTPS для безопасного соединения

- **Неправильно:**

  ```http
  http://example.com/api
  ```

- **Правильно:**

  ```http
  https://example.com/api    # SSL/TLS для шифрования данных
  ```

## 23. Не возвращать лишнюю информацию в сообщениях об ошибках

- **Неправильно:**

  ```json
  {
  	"error": "NullPointerException at com.example.service.UserService",
  	"stack": "com.example.service.UserService.java:45"
  }
  ```

- **Правильно:**

  ```json
  {
  	"error": "Внутренняя ошибка сервера"
  }
  ```

## 24. Реализовать надёжную аутентификацию и авторизацию

- **Аутентификация:**

  - Basic Auth (для простых случаев)
  - OAuth 2.0 (надёжный стандарт)
  - JWT (для stateless-решений)

- **Авторизация:**

  - OAuth 2.0 с scope/ролями
  - OpenID Connect (для управления идентификацией)
  - RBAC/ABAC (модели ролей и прав доступа)

## 25. Встраивать безопасность на этапе проектирования API

- **Неправильно:**
  Добавлять меры безопасности после реализации функционала.
- **Правильно:**
  Интегрировать требования безопасности (аутентификация, авторизация, валидация данных, шифрование) с начала разработки.
